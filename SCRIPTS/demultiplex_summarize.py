#!/usr/bin/env python
import argparse
parser = argparse.ArgumentParser(description='Script to demultiplex an Input IGB.tsv with the Barcode table from 1_Demultiplex_UMI_Extraction.sh')
parser.add_argument('-o','--OUT',help= "Path to Outfolder", required=False, default='./' )
parser.add_argument('-igb','--IGB',help="Path to IgBlast tsv that should be demultiplexed and summarized.",default="")
parser.add_argument('-n','--NAME',help="Name of the Pipeline. Defaults to fastq basename_date", required=False,default="" )
parser.add_argument('-bc','--UMI_BC',help="Path to UMI Barcode Dataframe generated by 1_Demultiplex_UMI_Extraction.sh", required=False,default="" )
parser.add_argument('-m','--MOD',help="Specify if the ReadID is modified by PyChopper.", required=False,default=True )
parser.add_argument('-s','--SEP',help="Specify the Separator of the Input Table.", required=False,default='\t' )
parser.add_argument('-on','--OUTN',help="Specify the Outname_ending, defaults to SampleName_vdj_umi_barcode_uncorrected_df.", required=False,default='vdj_umi_barcode_uncorrected_df' )
parser.add_argument('-c','--COLS',help="Column Names to look for in the Input DF for: Read ID, TCR Locus, V,D,J,CDR3 nt, CDR3 aa; keep same order!", required=False,default="sequence_id,locus,v_call,d_call,j_call,cdr3,cdr3_aa" )
args = parser.parse_args()

arg_vars = vars(args)

##################### Import Modules ############################
import modin.pandas as pmd
import sys
import os
import json
import pandas as pd
from datetime import datetime
from pathlib import Path

#######################################################
#################### Variables ########################
 
OUT=str(arg_vars["OUT"])
ending=str(arg_vars["OUTN"])
read_dir=arg_vars["IGB"]
sample_name=arg_vars["NAME"]

if sample_name == '':
    sample_name=os.path.basename(os.path.basename(read_dir)).split('.')[0]+'_'+datetime.now().strftime('%d_%m')
else:
    sample_name=arg_vars["NAME"]
    
SEP=arg_vars["SEP"]
umi_bc=Path(arg_vars["UMI_BC"])
col_names=arg_vars["COLS"]
col_names=col_names.split(',')
print('Reading only columns with names:',col_names)

MOD_READ_ID=arg_vars['MOD']
#print(MOD_READ_ID, type(MOD_READ_ID))
#############################################
## Read in VDJ Annotation File
vdj=pd.read_csv(read_dir,sep=SEP,usecols=col_names)

### Modify ReadID
if MOD_READ_ID == "":
    vdj['sequence_id']=vdj['sequence_id'].str.split('runid').str[0]
    vdj=vdj.rename(columns={'sequence_id':'ReadID'})

else:
    vdj['sequence_id']=vdj['sequence_id'].str.split('|',n=1).str[1]
    vdj['sequence_id']=vdj['sequence_id'].str.split('runid').str[0]
    vdj=vdj.rename(columns={'sequence_id':'ReadID'})
### Modifying Column Names
vdj=vdj.rename(columns={col_names[0]:'ReadID',col_names[1]:'Locus',col_names[2]:'V',col_names[3]:'D',col_names[4]:'J',col_names[5]:'CDR3',col_names[6]:'CDR3_aa'})

#print(vdj)  
### Read in umi barcode dataframe
umi_barcode_df=pd.read_csv(umi_bc)

#print(umi_barcode_df)
## Demultiplex VDJ Annotation File with Barcode and UMI File
demux_umi_df=pd.merge(left=vdj,right=umi_barcode_df,on='ReadID')
print("VDJ Dataframe with UMIs: \n",demux_umi_df)
demux_umi_df.to_csv('{0}/{1}_{2}.csv'.format(OUT,sample_name,ending),index=False)