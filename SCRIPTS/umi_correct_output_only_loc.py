#!/usr/bin/env python
import argparse
from random import sample
parser = argparse.ArgumentParser(description='Script to UMI Correct TCR Table generated by SPTCR-seq Pipeline')

parser.add_argument('-O','--OUT',help= "Path to Outfolder", required=False, default='./' )
parser.add_argument('-igb','--IGB',help="Path to IgBlast csv that should be UMI-corrected. IMPORTANT: Expects Columns: Locus, V, D, J, CDR3_aa, Spatial Barcode, UMI as generated by SPTCR-seq Pipeline",default="")
parser.add_argument('-bc','--BCOL',help="Name of the Barcode Column in the Input csv", required=False,default="Spatial Barcode" )
parser.add_argument('-umi','--UMICOL',help="Name of the UMI Column in the Input csv", required=False,default="UMI" )
parser.add_argument('-n','--NAME',help="Name of the Pipeline. Defaults to fastq basename_date", required=False,default="" )
parser.add_argument('-outn','--OUTNAME',help="Extension to add to outfile", required=False,default="_umi_corrected_count_table" )
parser.add_argument('-d','--STRDIST',help="String Distance to use for UMI Clustering", default=2 )


args = parser.parse_args()

arg_vars = vars(args)

###################### Example ################################
    #"${REPOSITORY}/SCRIPTS/umi_correct_output_only_loc.py" \
    #    -igb "${OUTFOLDER}/${SAMPLE_NAME}_uncorrected_igb_overview_igb.csv" \
    #    -n "${SAMPLE_NAME}" \
    #    -outn 'uncorrected_only_loc_umi_corrected_count_table' \
    #    -O "${OUTFOLDER}"


##################### Import Modules ############################
from umi_tools import UMIClusterer
from collections import defaultdict, Counter
import pandas as pd
from tqdm import tqdm
import os

### Disable Setting Value on Copy Warning
pd.options.mode.chained_assignment = None

#######################################################
#################### Variables ########################
OUT=str(arg_vars["OUT"])
sample_name=arg_vars["NAME"]
read_dir=arg_vars["IGB"]
string_dist=arg_vars["STRDIST"]
barcode_col=arg_vars["BCOL"]
umi_col=arg_vars["UMICOL"]
OUTNAME=arg_vars["OUTNAME"]
#######################################################
############ Summarizing and Preparing DF #############

## Reading in IGB
igb=pd.read_csv(read_dir)

### Preparing Data
igb=igb.dropna(subset=['Locus'])
igb=igb[['Locus',barcode_col,umi_col]]
igb=igb.groupby(['Locus','Spatial Barcode'])['UMI'].apply(list).reset_index(name='UMI List')
igb['Uncorrected Count']=igb.apply(lambda x: len(x['UMI List']),axis='columns')
igb=igb.sort_values(by='Uncorrected Count',ascending=False).reset_index(drop=True)

#######################################################
##################### UMI Correcting ##################
clusterer = UMIClusterer(cluster_method="directional")

igb=igb.reset_index(drop=True)

igb['UMI Corrected']=""

for index, row in tqdm(igb.iterrows()):
    if row['Uncorrected Count'] > 1:
        umi_bytes=[str.encode(umi) for umi in row['UMI List']]
        umis=dict(Counter(umi_bytes))
        clustered_umis = clusterer(umis, threshold=2)
        igb.loc[index,'UMI Corrected']=len(clustered_umis)
    else:
        igb.loc[index,'UMI Corrected']=1
        
igb=igb[["Locus","Spatial Barcode","Uncorrected Count","UMI Corrected"]]
print(igb)

#######################################################
##################### Write File Out ##################
#out_path=os.path(OUT)
write_name=sample_name+"_{0}.csv".format(OUTNAME)
outpath=os.path.join(OUT,write_name)
igb.to_csv(outpath,index=False)